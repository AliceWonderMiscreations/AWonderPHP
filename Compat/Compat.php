<?php
declare(strict_types=1);

/**
 * Alternative to PHP built in functions.
 *
 * In most cases, these are either core PHP functions that have been deprecated
 * or are likely to be deprecated.
 *
 * When the name is identical to a built-in PHP function the parameters and
 * output should be the same. When the name is not identical, the parameters and/or
 * output differ but usually it still should behave as a drop-in replacement.
 *
 * Intent is API compatible drop in replacements. However please note that in
 * cases where the PHP function is deprecated, it usually is deprecated for a
 * good reason, so a different way should be found.
 *
 * @package AWonderPHP/Compat
 * @author  Alice Wonder <paypal@domblogger.net>
 * @license https://opensource.org/licenses/MIT MIT
 * @version 0.1
 * @link    https://github.com/AliceWonderMiscreations/AWonderPHP
 */

namespace AWonderPHP;

/**
 * Static methods that provides alternatives to PHP functions of same name.
 */
class Compat
{
    /**
     * Replacement for the php uniqid function but using a pRNG for initial $more_entropy.
     * The uniqid function in php may become deprecated so this can be used instead if it
     * is actually needed, and produces compatible output.
     *
     * Like the native function, not suitable for cryptography purposes.
     *
     * In most cases you should use Compat::cryptoUniqid but if you need exact same output
     * format and do not need cryptographically strong, this one will do the job.
     *
     * About 2 times slower than native but much more collision resistant.
     *
     * @param string      $prefix       Optional. A prefix to use. Defaults to empty string.
     * @param bool        $more_entropy Optional. Whether or not additional entropy is needed.
     *
     * @return string The unique ID.
     */
    public static function uniqid(string $prefix = '', bool $more_entropy = false): string
    {
        static $nonce = null;
        if (is_null($nonce)) {
            $nonce = random_bytes(16);
        }
        $m = microtime(true);
        $return = sprintf("%8x%05x", floor($m), ($m-floor($m))*1000000);
        if ($more_entropy) {
            sodium_increment($nonce);
            $x = hexdec(substr(bin2hex($nonce), 0, 12));
            $return = $return . substr($x, 2, 1) . '.' . substr($x, -8);
        }
        return $prefix . $return;
    }//end uniqid()
    
    /**
     * Mostly API compatible replacement for uniqid that still includes timestamp but provides
     * actual collision resistant nonce capabilities, but output is not same format. Should still
     * work as drop in replacement in most cases.
     *
     * When the second argument is false, the random portion can be guessed if more than one token
     * is generated by the same script. When the second argument is true, the random portion is not
     * guessable.
     *
     * @param string      $prefix Optional. A prefix to use. Defaults to empty string.
     * @param bool        $prng   Optional. Whether or not to use pRNG on each call. Defaults to
     *                            false. If you only need collision resistance then leave false. If
     *                            it must also not be predictable then set to true.
     * @param int         $bytes  Optional. Number of bytes to use for random part. Defaults to 16,
     *                            uses 12 if less than 12 is specified.
     *
     * @return string The unique ID.
     */
    public static function cryptoUniqid(string $prefix = '', bool $prng = false, int $bytes = 16): string
    {
        static $nonce = null;
        if ($bytes < 12) {
            $byres = 12;
        }
        if ($prng || is_null($nonce)) {
            $nonce = random_bytes(16);
        } else {
            sodium_increment($nonce);
        }
        $return = time() . '.' . base64_encode($nonce);
        return $prefix . $return;
    }//end cryptoUniqid()
}//end class

?>